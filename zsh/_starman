#compdef starman

# Generated with perl module App::Spec v0.010

_starman() {
    local program=starman
    typeset -A opt_args
    local curcontext="$curcontext" state line context


        # ---- Command: 
        _arguments -s  \
            '1: :->file' \
            '*--listen[Specifies the TCP address, ports and UNIX domain sockets]:listen' \
            '*-l[Specifies the TCP address, ports and UNIX domain sockets]:listen' \
            '--host[Specifies the address to bind]:host' \
            '--port[Specifies the port to bind]:port' \
            '--socket[Specifies the path to UNIX domain socket to bind]:socket:_files' \
            '-S[Specifies the path to UNIX domain socket to bind]:socket:_files' \
            '--workers[Specifies the number of worker pool]:workers' \
            '--backlog[Specifies the number of backlog (listen queue size)...]:backlog' \
            '--max-requests[Number of the requests to process per one worker process]' \
            '--preload-app[This option lets Starman preload the specified PSGI application...]' \
            '--disable-keepalive[Disable Keep-alive persistent connections]' \
            '--keepalive-timeout[The number of seconds Starman will wait for a subsequent request]:keepalive-timeout' \
            '--read-timeout[The number of seconds Starman will wait for a request on a new...]:read-timeout' \
            '--user[To listen on a low-numbered (<1024) port...]:user' \
            '--group[Specify the group id or group name that the server...]:group' \
            '--pid[Specify the pid file path]:pid:_files' \
            '--error-log[Specify the pathname of a file where the error log...]:error-log:_files' \
            '--ssl-cert[Specify the path to SSL certificate file]:ssl-cert:_files' \
            '--ssl-key[Specify the path to SSL key file]:ssl-key:_files' \
            '--enable-ssl[Enable SSL on all TCP sockets]' \
            '--disable-proctitle[Disable the behavior to set proctitle to "starman (master)"]' \
            '--app[Specifies the full path to a ".psgi" script]:app:_files' \
            '-a[Specifies the full path to a ".psgi" script]:app:_files' \
            '-e[Evaluates the given perl code as a PSGI app]:e' \
            '--server[Selects a specific server implementation to run on]:server' \
            '-s[Selects a specific server implementation to run on]:server' \
            '--socket[Listens on a UNIX domain socket path]:socket' \
            '-S[Listens on a UNIX domain socket path]:socket' \
            '--daemonize[Makes the process run in the background]' \
            '-D[Makes the process run in the background]' \
            '*-I[Specifies Perl library include paths]:I' \
            '*-M[Loads the named modules before loading the app'"'"'s code]:M' \
            '--env[Specifies the environment option]:env' \
            '-E[Specifies the environment option]:env' \
            '--no-default-middleware[This prevents loading the default middleware stack...]' \
            '--reload[Makes plackup restart the server whenever a file...]' \
            '-r[Makes plackup restart the server whenever a file...]' \
            '--Reload[Makes plackup restart the server whenever a given file...]:Reload:_files' \
            '-R[Makes plackup restart the server whenever a given file...]:Reload:_files' \
            '--access-log[Specifies the pathname of a file where the access log...]:access-log:_files' \
            '--path[Specify the root path of your app]:path' \
            '--loader[Specifies the server loading subclass]:loader:("Restarter" "Delayed" "Shotgun")' \
            '-L[Specifies the server loading subclass]:loader:("Restarter" "Delayed" "Shotgun")' \
            '--help[Show command help]' \
            '-h[Show command help]' \
            && ret=0

        case $state in
        file)
_files
        ;;
        esac


}


__starman_dynamic_comp() {
    local argname="$1"
    local arg="$2"
    local comp="arg:$argname:(("
    local line
    while read -r line; do
        local name="$line"
        local desc="$line"
        name="${name%$'\t'*}"
        desc="${desc/*$'\t'}"
        comp="$comp$name"
        if [[ -n "$desc" && "$name" != "$desc" ]]; then
            comp="$comp\\:"'"'"$desc"'"'
        fi
        comp="$comp "
    done <<< "$arg"

    comp="$comp))"
    _alternative "$comp"
}

